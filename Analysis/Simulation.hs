{-# LANGUAGE OverloadedStrings, LambdaCase #-}
-- | Module Analysis.Simulation
--
-- Simulate races using the performance model.
module Analysis.Simulation
    ( SimPip(..)
    , SimEntry(..)
    , SimOptions(..)
    , toSimPips
    , simulateSingleRace
    , runExperimentFull
    , runExperimentPip
    , runExperimentProbe
    , simModelStrength
    ) where

import Types
import Analysis.PerfModel.Orbital
import Util.Lone (surroundL)

import System.Random.MWC
import Statistics.Distribution

import Data.Bifunctor
import qualified Data.Map.Strict as Map
import Data.Map.Strict (Map)
import Data.List
import Data.Ord
import Pipes
import qualified Pipes.Prelude as P
import Data.Default.Class

-- | Racer identification. The type is augmented by testing probes.
data SimPip = Probe !Int | SimPip !PipId
    deriving (Eq, Ord, Show)

-- | Racer result with rank generated by the simulation.
data SimEntry = SimEntry
    { simPip :: !SimPip
    , laptimeDelta :: !Double
    , pipRank :: !Int
    }
    deriving (Eq, Ord, Show)

-- | Prepare ratings from the engine to feed the simulation.
toSimPips
    :: [(Int, Double)]                 -- ^ Identifications and ratings of the probes.
    -> Ratings                         -- ^ Ratings map from the engine.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
toSimPips probes rtgs = map (second (OrbitalDistribution . kFromRating))
    $ map (first Probe) probes
    ++ map (bimap SimPip rating) (Map.assocs rtgs)

-- | Stream of simulated race results.
simulator
    :: Maybe Seed                        -- ^ Generator seed.
    -> [(SimPip, OrbitalDistribution)]   -- ^ Identifications and performance models.
    -> Producer [SimEntry] IO ()         -- ^ Identifications and laptime deltas.
simulator seed pips = do
    g <- liftIO $ maybe createSystemRandom restore seed
    P.repeatM $ do
        results <- traverse (surroundL (flip genContVar g)) $ pips
        return $ zipWith (uncurry SimEntry) (sortBy (comparing snd) results) [1..]

-- | Generates results of a single race.
simulateSingleRace
    :: Maybe Seed                      -- ^ Generator seed.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO [SimEntry]                   -- ^ Identifications and laptime deltas.
simulateSingleRace seed pips =
    P.head (simulator seed pips) >>= \case
        Just res -> return res
        Nothing -> error "Analysis.Simulation: simulator exhausted"

-- | Generates results of many races and tallies how often racers reached each
-- position.
runExperimentFull
    :: Maybe Seed                      -- ^ Generator seed.
    -> Int                             -- ^ Number of runs.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO (Map (SimPip, Int) Int)      -- ^ Count of racer-rank pairs.
runExperimentFull seed nRuns pips = P.fold updateCount counters id entries
    where
    counters = Map.empty
    entries = simulator seed pips >-> P.take nRuns >-> P.mapFoldable id
    updateCount ctrs se =
        Map.alter (maybe (Just 1) (Just . (+ 1))) (simPip se, pipRank se) ctrs

-- | Generates results of many races and tallies how often a specific racer
-- reached each position.
runExperimentPip
    :: Maybe Seed                      -- ^ Generator seed.
    -> Int                             -- ^ Number of runs.
    -> SimPip                          -- ^ Selected racer.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO (Map Int Int)                -- ^ Count of racer-rank pairs.
runExperimentPip seed nRuns selPip pips =
    P.fold updateCount counters id entries
    where
    counters = Map.empty
    entries = simulator seed pips >-> P.take nRuns >-> P.mapFoldable id
        >-> P.filter ((selPip ==) . simPip)
    updateCount ctrs se =
        Map.alter (maybe (Just 1) (Just . (+ 1))) (pipRank se) ctrs
    -- Note that this doesn't seem to be noticeably faster than
    -- runExperimentFull.

-- | Generates results of many races with an added probe and tallies how often
-- the probe reached each position.
runExperimentProbe
    :: SimOptions                      -- ^ Number of runs, seed, and probe.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO (Map Int Int)                -- ^ Count of racer-rank pairs.
runExperimentProbe simOpts pips =
    runExperimentPip seed nRuns probeId ((probeId, probeModel) : pips)
    where
    seed = simSeed simOpts
    nRuns = simRuns simOpts
    probeModel = OrbitalDistribution (kFromRating (simProbeRating simOpts))
    probeId = Probe 0

simModelStrength :: SimOptions -> Ratings -> IO Double
simModelStrength simOpts = fmap ((fromIntegral nRuns /) . fromIntegral
        . Map.foldl' (+) 0 . Map.filterWithKey (\key _ -> isTargetReached key))
    . runExperimentProbe simOpts . toSimPips []
    where
    nRuns = simRuns simOpts
    isTargetReached = (<= simTarget simOpts)


data SimOptions = SimOptions
    { simSeed :: Maybe Seed    -- ^ A random generator seed supplied by the
                               -- caller. If 'Nothing', the simulation
                               -- engine will set up a fresh generator.
    , simProbeRating :: Double -- ^ Rating of the probe that will be used
                               -- as a reference in the strength
                               -- calculations.
    , simTarget :: Int         -- ^ Tally the top-n results attained by
                               -- the probe.
    , simRuns :: Int           -- ^ How many times each race should be
                               -- simulated.
    }
    deriving (Eq, Show)

instance Default SimOptions where
    def = SimOptions
        { simSeed = Nothing
        , simProbeRating = 1500
        , simTarget = 5
        , simRuns = 10000
        }

example = bimap SimPip OrbitalDistribution
    <$> [("HAM", 250), ("BOT", 143), ("VER", 215), ("VET", 190), ("STR", 120)]

-- $> :set -XOverloadedStrings
-- $>
-- $> :set +s
-- $>
-- >$> simulateSingleRace Nothing example
--
-- $> runExperimentFull Nothing 10000 example
