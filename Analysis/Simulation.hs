{-# LANGUAGE OverloadedStrings, LambdaCase, GeneralisedNewtypeDeriving #-}
-- | Module Analysis.Simulation
--
-- Simulate races using the performance model.
module Analysis.Simulation
    ( SimPip(..)
    , SimEntry(..)
    , SimOptions(..)
    , toSimPips
    , simulateSingleRace
    , runExperimentFull
    , runExperimentPip
    , runExperimentProbe
    , simModelStrength
    , simAveragePositions
    , SimM(..)
    , runSimM
    , evalSimM
    ) where

import Types
import Analysis.PerfModel.Orbital
import Util.Lone (surroundL)

import System.Random.MWC
import Statistics.Distribution

import Data.Bifunctor
import qualified Data.Map.Strict as Map
import Data.Map.Strict (Map)
import Data.List
import Data.Ord
import Pipes
import qualified Pipes.Prelude as P
import Data.Default.Class
import Control.Monad.State.Strict

-- | Racer identification. The type is augmented by testing probes.
data SimPip = Probe !Int | SimPip !PipId
    deriving (Eq, Ord, Show)

-- | Racer result with rank generated by the simulation.
data SimEntry = SimEntry
    { simPip :: !SimPip
    , laptimeDelta :: !Double
    , pipRank :: !Int
    }
    deriving (Eq, Ord, Show)

-- | Prepare ratings from the engine to feed the simulation.
toSimPips
    :: [(Int, Double)]                  -- ^ Identifications and ratings of the probes.
    -> Ratings                          -- ^ Ratings map from the engine.
    -> [(SimPip, OrbitalDistribution)]  -- ^ Identifications and performance models.
toSimPips probes rtgs = map (second (orbitalDistr . kFromRating))
    $ map (first Probe) probes
    ++ map (bimap SimPip rating) (Map.assocs rtgs)

-- | Infinite stream of simulated race results. If the number of runs that
-- will be used is known in advance, it is slightly less efficient than
-- 'simulatorN', as it has to save the generator state after each run.
simulator
    :: [(SimPip, OrbitalDistribution)]   -- ^ Identifications and performance models.
    -> Producer [SimEntry] SimM ()       -- ^ Identifications and laptime deltas.
simulator pips = do
    seed <- get
    g <- liftIO $ restore seed
    P.repeatM $ do
        results <- liftIO $ traverse (surroundL (flip genContVar g)) pips
        newSeed <- liftIO $ save g
        put newSeed
        return $ zipWith (uncurry SimEntry) (sortBy (comparing snd) results) [1..]

-- | Stream of a finite number of simulated results. The updated generator
-- seed is used as the return value to make it harder to discard it
-- accidentally by interrupting the stream. For interrupting the stream, use
-- 'void' to discard the return value, or switch to 'simulator' if it is
-- important to update the generator state.
simulatorN
    :: Int                               -- ^ Number of simulations
    -> [(SimPip, OrbitalDistribution)]   -- ^ Identifications and performance models.
    -> Producer [SimEntry] SimM Seed     -- ^ Identifications and laptime deltas.
simulatorN nRuns pips = do
    seed <- get
    g <- liftIO $ restore seed
    P.replicateM nRuns $ do
        results <- liftIO $ traverse (surroundL (flip genContVar g)) pips
        return $ zipWith (uncurry SimEntry) (sortBy (comparing snd) results) [1..]
    newSeed <- liftIO $ save g
    put newSeed
    return newSeed

-- | Generates results of a single race.
simulateSingleRace
    :: [(SimPip, OrbitalDistribution)]  -- ^ Identifications and performance models.
    -> SimM [SimEntry]                  -- ^ Identifications and laptime deltas.
simulateSingleRace pips = do
    P.head (void $ simulatorN 1 pips) >>= \case
        Just res -> return res
        Nothing -> error "Analysis.Simulation: simulator exhausted"

-- | Generates results of many races and tallies how often racers reached each
-- position.
runExperimentFull
    :: Int                              -- ^ Number of runs.
    -> [(SimPip, OrbitalDistribution)]  -- ^ Identifications and performance models.
    -> SimM (Map (SimPip, Int) Int)     -- ^ Count of racer-rank pairs.
runExperimentFull nRuns pips = fst <$> P.fold' updateCount counters id entries
    where
    counters = Map.empty
    entries = simulatorN nRuns pips >-> P.mapFoldable id
    updateCount ctrs se =
        Map.alter (maybe (Just 1) (Just . (+ 1))) (simPip se, pipRank se) ctrs

-- | Generates results of many races and tallies how often a specific racer
-- reached each position.
runExperimentPip
    :: Int                               -- ^ Number of runs.
    -> SimPip                            -- ^ Selected racer.
    -> [(SimPip, OrbitalDistribution)]   -- ^ Identifications and performance models.
    -> SimM (Map Int Int)                -- ^ Count of racer-rank pairs.
runExperimentPip nRuns selPip pips =
    fst <$> P.fold' updateCount counters id entries
    where
    counters = Map.empty
    entries = simulatorN nRuns pips >-> P.mapFoldable id
        >-> P.filter ((selPip ==) . simPip)
    updateCount ctrs se =
        Map.alter (maybe (Just 1) (Just . (+ 1))) (pipRank se) ctrs
    -- Note that this doesn't seem to be noticeably faster than
    -- runExperimentFull.

-- | Generates results of many races with an added probe and tallies how often
-- the probe reached each position.
runExperimentProbe
    :: SimOptions                        -- ^ Number of runs, seed, and probe.
    -> [(SimPip, OrbitalDistribution)]   -- ^ Identifications and performance models.
    -> SimM (Map Int Int)                -- ^ Count of racer-rank pairs.
runExperimentProbe simOpts pips =
    runExperimentPip nRuns probeId ((probeId, probeModel) : pips)
    where
    nRuns = simRuns simOpts
    probeModel = orbitalDistr (kFromRating (simProbeRating simOpts))
    probeId = Probe 0

simModelStrength :: SimOptions -> Ratings -> SimM Double
simModelStrength simOpts = fmap ((fromIntegral nRuns /) . fromIntegral
        . Map.foldl' (+) 0 . Map.filterWithKey (\key _ -> isTargetReached key))
    . runExperimentProbe simOpts . toSimPips []
    where
    nRuns = simRuns simOpts
    isTargetReached = (<= simTarget simOpts)

-- | Average positions attained by racers in the simulations.
simAveragePositions :: SimOptions -> Ratings -> SimM (Map SimPip Double)
simAveragePositions simOpts = fmap (fmap (/ fromIntegral nRuns)
        . Map.mapKeysWith (+) fst
        . Map.mapWithKey (\(p, i) m -> fromIntegral i * fromIntegral m))
    . runExperimentFull nRuns . toSimPips []
    where
    nRuns = simRuns simOpts


example = bimap SimPip orbitalDistr
    <$> [("HAM", 250), ("BOT", 143), ("VER", 215), ("VET", 190), ("STR", 120)]

-- >$> :set -XOverloadedStrings
-- $>
-- >$> :set +s
-- $>
-- >$> evalSimM Nothing $ simulateSingleRace Nothing example
--
-- >$> evalSimM Nothing $ runExperimentFull 10000 example
