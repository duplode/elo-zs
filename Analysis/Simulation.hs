{-# LANGUAGE OverloadedStrings, LambdaCase #-}
-- | Module Analysis.Simulation
--
-- Simulate races using the performance model.
module Analysis.Simulation
    ( SimPip(..)
    , SimEntry(..)
    , toSimPips
    , simulateSingleRace
    , runExperimentFull
    , runExperimentPip
    , runExperimentProbe
    , simModelStrength
    ) where

import Types
import Analysis.PerfModel.Orbital

import System.Random.MWC
import Statistics.Distribution

import Data.Bifunctor
import qualified Data.Map.Strict as Map
import Data.Map.Strict (Map)
import Data.List
import Data.Ord
import Pipes
import qualified Pipes.Prelude as P

-- | Racer identification. The type is augmented by testing probes.
data SimPip = Probe !Int | SimPip !PipId
    deriving (Eq, Ord, Show)

-- | Racer result with rank generated by the simulation.
data SimEntry = SimEntry
    { simPip :: !SimPip
    , laptimeDelta :: !Double
    , pipRank :: !Int
    }
    deriving (Eq, Ord, Show)

-- | Prepare ratings from the engine to feed the simulation.
toSimPips
    :: [(Int, Double)]                 -- ^ Identifications and ratings of the probes.
    -> Ratings                         -- ^ Ratings map from the engine.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
toSimPips probes rtgs = map (second (OrbitalDistribution . kFromRating))
    $ map (first Probe) probes
    ++ map (bimap SimPip rating) (Map.assocs rtgs)

-- | Stream of simulated race results.
simulator
    :: [(SimPip, OrbitalDistribution)]   -- ^ Identifications and performance models.
    -> Producer [SimEntry] IO ()         -- ^ Identifications and laptime deltas.
simulator pips = P.repeatM $ do
    g <- createSystemRandom
    results <- sequenceA
        . fmap (sequenceA . second (flip genContVar g)) $ pips
    return $ zipWith (uncurry SimEntry) (sortBy (comparing snd) results) [1..]

-- | Generates results of a single race.
simulateSingleRace
    :: [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO [SimEntry]                   -- ^ Identifications and laptime deltas.
simulateSingleRace pips =
    P.head (simulator pips) >>= \case
        Just res -> return res
        Nothing -> error "Analysis.Simulation: simulator exhausted"

-- | Generates results of many races and tallies how often racers reached each
-- position.
runExperimentFull
    :: Int                             -- ^ Number of runs.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO (Map (SimPip, Int) Int)      -- ^ Count of racer-rank pairs.
runExperimentFull nRuns pips = P.fold updateCount counters id entries
    where
    counters = Map.empty
    entries = simulator pips >-> P.take nRuns >-> P.mapFoldable id
    updateCount ctrs se =
        Map.alter (maybe (Just 1) (Just . (+ 1))) (simPip se, pipRank se) ctrs

-- | Generates results of many races and tallies how often a specific racer
-- reached each position.
runExperimentPip
    :: Int                             -- ^ Number of runs.
    -> SimPip                          -- ^ Selected racer.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO (Map Int Int)                -- ^ Count of racer-rank pairs.
runExperimentPip nRuns selPip pips = P.fold updateCount counters id entries
    where
    counters = Map.empty
    entries = simulator pips >-> P.take nRuns >-> P.mapFoldable id
        >-> P.filter ((selPip ==) . simPip)
    updateCount ctrs se =
        Map.alter (maybe (Just 1) (Just . (+ 1))) (pipRank se) ctrs
    -- Note that this doesn't seem to be noticeably faster than
    -- runExperimentFull.

-- | Generates results of many races with an added probe and tallies how often
-- the probe reached each position.
runExperimentProbe
    :: Int                             -- ^ Number of runs.
    -> OrbitalDistribution             -- ^ Model for the probe.
    -> [(SimPip, OrbitalDistribution)] -- ^ Identifications and performance models.
    -> IO (Map Int Int)                -- ^ Count of racer-rank pairs.
runExperimentProbe nRuns probeModel pips =
    runExperimentPip nRuns probeId ((probeId, probeModel) : pips)
    where
    probeId = Probe 0

simModelStrength :: Int -> Ratings -> IO Double
simModelStrength nRuns = fmap ((fromIntegral nRuns /) . fromIntegral
        . Map.foldl' (+) 0 . Map.filterWithKey (\key _ -> isTargetReached key))
    . runExperimentProbe nRuns probeModel . toSimPips []
    where
    probeModel = OrbitalDistribution (kFromRating 1500)  -- TODO: Make this configurable.
    isTargetReached = (<= 5)  -- TODO: Make this configurable.

example = bimap SimPip OrbitalDistribution
    <$> [("HAM", 250), ("BOT", 143), ("VER", 215), ("VET", 190), ("STR", 120)]

-- $> :set -XOverloadedStrings
-- $>
-- $> :set +s
-- $>
-- $> simulateSingleRace example
--
-- >$> runExperimentFull 10000 example
